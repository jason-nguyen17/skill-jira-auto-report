This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
skills/
  jira-self-hosted/
    references/
      api-reference.md
      authentication.md
      best-practices.md
      jql-guide.md
    scripts/
      jira-auth-test.sh
      jira-issue-get.sh
      jira-search.sh
    SKILL.md
.env.example
.gitignore
daily-report.mjs
env.claude
install-skill.sh
README.md
run-daily-report.sh
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="skills/jira-self-hosted/references/api-reference.md">
# Jira REST API v2 Reference

## Base Configuration

```
Base URL: {JIRA_DOMAIN}/rest/api/2
Headers:
  Authorization: Bearer {JIRA_PAT}
  Content-Type: application/json
```

## Search Issues (JQL)

### POST /search (Recommended)

Best for complex JQL queries with field selection.

```bash
curl -s -X POST \
  -H "Authorization: Bearer $JIRA_PAT" \
  -H "Content-Type: application/json" \
  -d '{
    "jql": "project = PROJ AND status = Open",
    "startAt": 0,
    "maxResults": 50,
    "fields": ["key", "summary", "status", "assignee", "priority"]
  }' \
  "${JIRA_DOMAIN}/rest/api/2/search"
```

**Request Body**

| Field | Type | Description |
|-------|------|-------------|
| jql | string | JQL query string |
| startAt | int | Pagination offset (default: 0) |
| maxResults | int | Max results per page (default: 50, max: 100) |
| fields | array | Fields to return (reduces payload) |

**Response**

```json
{
  "startAt": 0,
  "maxResults": 50,
  "total": 125,
  "issues": [
    {
      "key": "PROJ-123",
      "fields": {
        "summary": "Issue title",
        "status": {"name": "Open"},
        "assignee": {"displayName": "John Doe"},
        "priority": {"name": "High"}
      }
    }
  ]
}
```

### GET /search

Simple queries via URL parameters.

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/search?jql=project=PROJ&maxResults=10"
```

## Get Issue

### GET /issue/{key}

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/issue/PROJ-123"
```

**With Field Selection**

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/issue/PROJ-123?fields=summary,status,description,comment"
```

**Response**

```json
{
  "key": "PROJ-123",
  "fields": {
    "summary": "Issue title",
    "status": {"name": "In Progress"},
    "description": "Issue description text",
    "assignee": {"displayName": "John Doe", "emailAddress": "john@example.com"},
    "reporter": {"displayName": "Jane Smith"},
    "priority": {"name": "High"},
    "created": "2026-01-15T10:30:00.000+0000",
    "updated": "2026-01-20T14:45:00.000+0000",
    "comment": {
      "comments": [
        {"body": "Comment text", "author": {"displayName": "John"}}
      ]
    }
  }
}
```

## Comments

### GET /issue/{key}/comment

List all comments on an issue.

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/issue/PROJ-123/comment"
```

**Response**

```json
{
  "comments": [
    {
      "id": "10001",
      "body": "This is a comment",
      "author": {"displayName": "John Doe"},
      "created": "2026-01-15T10:30:00.000+0000",
      "updated": "2026-01-15T10:30:00.000+0000"
    }
  ],
  "total": 5
}
```

## Projects

### GET /project

List all accessible projects.

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/project"
```

**Response**

```json
[
  {
    "key": "PROJ",
    "name": "Project Name",
    "projectTypeKey": "software",
    "lead": {"displayName": "Project Lead"}
  }
]
```

### GET /project/{key}

Get project details.

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/project/PROJ"
```

## Pagination

For large result sets, use pagination:

```bash
# Page 1 (issues 0-49)
startAt=0&maxResults=50

# Page 2 (issues 50-99)
startAt=50&maxResults=50

# Page 3 (issues 100-149)
startAt=100&maxResults=50
```

**Check if more pages exist:**

```
hasMore = (startAt + maxResults) < total
```

## Common Fields

| Field | Description |
|-------|-------------|
| key | Issue key (e.g., PROJ-123) |
| summary | Issue title |
| description | Full description |
| status | Current status object |
| assignee | Assigned user object |
| reporter | Creator user object |
| priority | Priority level object |
| created | Creation timestamp |
| updated | Last update timestamp |
| labels | Array of label strings |
| components | Array of component objects |
| fixVersions | Target versions array |

## Error Responses

| Code | Meaning | Example |
|------|---------|---------|
| 400 | Bad Request | Invalid JQL syntax |
| 401 | Unauthorized | Invalid/expired PAT |
| 403 | Forbidden | No permission to resource |
| 404 | Not Found | Issue/project doesn't exist |

**Error Response Format**

```json
{
  "errorMessages": ["Issue does not exist or you do not have permission to see it"],
  "errors": {}
}
```
</file>

<file path="skills/jira-self-hosted/references/authentication.md">
# PAT Authentication for Jira Server/Data Center

## Overview

Personal Access Tokens (PAT) provide secure, token-based authentication for Jira REST API calls. PATs are preferred over Basic Auth for integrations.

| Method | Security | Use Case |
|--------|----------|----------|
| PAT Bearer | High | Integrations, automation, CI/CD |
| Basic Auth | Medium | Legacy, deprecated |
| OAuth 2.0 | High | Limited support in Server/DC |

## Prerequisites

- Jira Server v8.14.0+ or Data Center
- "Enhance API Security for Jira REST APIs" enabled in admin settings
- User account with appropriate project permissions

## Creating a PAT

1. Log in to Jira
2. Click **Profile icon** > **Profile**
3. Select **Personal Access Tokens** (left sidebar)
4. Click **Create token**
5. Enter token name (e.g., "Claude Integration")
6. Set expiration (recommended: 90 days)
7. Click **Create**
8. **Copy token immediately** (shown only once)

## Usage

### Header Format

```
Authorization: Bearer <your_pat_token>
```

### cURL Example

```bash
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  -H "Content-Type: application/json" \
  "${JIRA_DOMAIN}/rest/api/2/myself"
```

### Environment Variables

```bash
export JIRA_DOMAIN="https://your-jira-instance.com"
export JIRA_PAT="your_personal_access_token"
```

## Security Best Practices

1. **Use service accounts**: Create dedicated account for integrations
2. **Set expiration**: Always set token expiry (90 days recommended)
3. **Minimal permissions**: Grant only required project access
4. **Environment variables**: Never hardcode tokens in scripts
5. **Regular audits**: Review and revoke unused tokens
6. **HTTPS only**: Always use HTTPS for API calls

## Token Management

### View Active Tokens

Profile > Personal Access Tokens > View all tokens

### Revoke Token

Profile > Personal Access Tokens > Select token > Revoke

### Token Rotation

1. Create new token before old expires
2. Update integrations with new token
3. Revoke old token

## Troubleshooting

### 401 Unauthorized

- Token expired or invalid
- Token not properly formatted in header
- Missing "Bearer " prefix

**Fix**: Verify token, regenerate if expired

### 403 Forbidden

- User lacks project/issue permissions
- Token scope insufficient

**Fix**: Check user permissions in Jira admin

### PAT Feature Disabled

- Security app may block PAT authentication
- Admin settings may disable PATs

**Fix**: Contact Jira admin to enable PAT support

### Connection Errors

- Incorrect JIRA_DOMAIN URL
- Missing https:// prefix
- Firewall/VPN blocking access

**Fix**: Verify URL format and network connectivity

## Testing Connection

```bash
# Test PAT authentication
curl -s \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/myself" | jq '.displayName, .emailAddress'
```

Expected output: Your display name and email.
</file>

<file path="skills/jira-self-hosted/references/best-practices.md">
# Best Practices for Jira API Integration

## Error Handling

### HTTP Status Codes

| Code | Meaning | Action |
|------|---------|--------|
| 200 | Success | Process response |
| 400 | Bad Request | Check JQL syntax, validate JSON |
| 401 | Unauthorized | Refresh token, verify PAT |
| 403 | Forbidden | Check permissions |
| 404 | Not Found | Verify resource exists |
| 429 | Rate Limited | Implement backoff |
| 500 | Server Error | Retry with delay |

### Error Response Parsing

```bash
response=$(curl -s -w "\n%{http_code}" ...)
http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | sed '$d')

if [[ "$http_code" != "200" ]]; then
  error_msg=$(echo "$body" | jq -r '.errorMessages[0] // "Unknown error"')
  echo "Error: $error_msg" >&2
  exit 1
fi
```

### Retry Logic

```bash
max_retries=3
retry_delay=2

for ((i=1; i<=max_retries; i++)); do
  response=$(curl -s ...)
  if [[ $? -eq 0 ]]; then
    break
  fi
  sleep $((retry_delay * i))
done
```

## Rate Limits

### Server/Data Center

- No hard limits documented
- Implement client-side throttling
- Recommended: 2-5 requests/second

### Pagination

- Use `startAt` + `maxResults` for large queries
- Max 100 results per request
- Always check `total` vs returned count

```bash
# Paginated fetch
start_at=0
max_results=50
total=999

while [[ $start_at -lt $total ]]; do
  response=$(curl ... -d "{\"startAt\": $start_at, \"maxResults\": $max_results}")
  total=$(echo "$response" | jq '.total')
  # Process issues...
  start_at=$((start_at + max_results))
done
```

## Security

### Token Management

1. Store in environment variables
2. Never log or print tokens
3. Set token expiration (90 days max)
4. Use dedicated service accounts
5. Revoke unused tokens promptly

### Secure Storage

```bash
# Good: Environment variable
export JIRA_PAT="token"

# Good: .env file with restricted permissions
chmod 600 .env

# Bad: Hardcoded in script
JIRA_PAT="token"  # Never do this
```

### HTTPS Only

- Always use https:// URLs
- Verify SSL certificates
- Never disable certificate validation

## Performance

### Field Selection

Reduce payload by requesting only needed fields:

```bash
# Bad: Returns all fields
curl .../issue/PROJ-123

# Good: Returns only needed fields
curl ".../issue/PROJ-123?fields=summary,status,assignee"
```

### Efficient JQL

```jql
# Bad: Slow, returns many results
project = PROJ

# Good: Specific, fewer results
project = PROJ AND status = Open AND updated >= -7d
```

### Batch Operations

- Group related queries where possible
- Use search endpoint vs individual GET calls
- Cache frequently accessed data locally

## Common Patterns

### Check Issue Exists

```bash
http_code=$(curl -s -o /dev/null -w "%{http_code}" \
  -H "Authorization: Bearer $JIRA_PAT" \
  "${JIRA_DOMAIN}/rest/api/2/issue/PROJ-123")

if [[ "$http_code" == "200" ]]; then
  echo "Issue exists"
fi
```

### Extract Specific Fields

```bash
curl -s ... | jq '{
  key: .key,
  summary: .fields.summary,
  status: .fields.status.name,
  assignee: .fields.assignee.displayName
}'
```

### Count Results Only

```bash
curl -s ... -d '{"jql": "...", "maxResults": 0}' | jq '.total'
```

## Troubleshooting

### Connection Issues

- Verify JIRA_DOMAIN URL format (include https://)
- Check firewall/VPN access
- Test with curl verbose: `curl -v ...`

### Authentication Failures

- Verify PAT not expired
- Check user permissions
- Confirm PAT feature enabled in Jira admin

### JQL Errors

- Validate query syntax in Jira UI first
- Quote values with spaces
- Escape special characters
</file>

<file path="skills/jira-self-hosted/references/jql-guide.md">
# JQL (Jira Query Language) Guide

## Basic Syntax

```
field operator value [AND|OR field operator value]... [ORDER BY field [ASC|DESC]]
```

## Operators

| Operator | Description | Example |
|----------|-------------|---------|
| = | Equals | `status = "Open"` |
| != | Not equals | `status != Done` |
| ~ | Contains (text) | `summary ~ "bug"` |
| !~ | Not contains | `summary !~ "test"` |
| > | Greater than | `created > -7d` |
| >= | Greater or equal | `priority >= High` |
| < | Less than | `updated < -30d` |
| <= | Less or equal | `duedate <= endOfWeek()` |
| IN | In list | `status IN (Open, "In Progress")` |
| NOT IN | Not in list | `priority NOT IN (Low, Lowest)` |
| IS | Null check | `assignee IS EMPTY` |
| IS NOT | Not null | `assignee IS NOT EMPTY` |
| WAS | Historical | `status WAS "Open"` |
| CHANGED | Changed | `status CHANGED` |

## Keywords

| Keyword | Description |
|---------|-------------|
| AND | Both conditions must match |
| OR | Either condition matches |
| NOT | Negate condition |
| ORDER BY | Sort results |
| ASC | Ascending order |
| DESC | Descending order |

## Common Fields

| Field | Type | Description |
|-------|------|-------------|
| project | Text | Project key (e.g., PROJ) |
| status | Text | Issue status |
| assignee | User | Assigned user |
| reporter | User | Issue creator |
| priority | Text | Priority level |
| type | Text | Issue type (Bug, Task, Story) |
| created | Date | Creation date |
| updated | Date | Last update date |
| duedate | Date | Due date |
| resolution | Text | Resolution status |
| labels | Text | Issue labels |
| component | Text | Component name |
| fixVersion | Text | Target version |
| sprint | Text | Sprint name |
| summary | Text | Issue title |
| description | Text | Issue description |

## Date Functions

| Function | Description |
|----------|-------------|
| now() | Current timestamp |
| currentUser() | Logged-in user |
| startOfDay() | Start of today |
| endOfDay() | End of today |
| startOfWeek() | Start of current week |
| endOfWeek() | End of current week |
| startOfMonth() | Start of current month |
| endOfMonth() | End of current month |
| startOfYear() | Start of current year |

## Relative Dates

| Format | Description |
|--------|-------------|
| -1d | 1 day ago |
| -7d | 7 days ago |
| -1w | 1 week ago |
| -1m | 1 month ago |
| +1d | 1 day from now |

## Sprint Functions

| Function | Description |
|----------|-------------|
| openSprints() | All open sprints |
| closedSprints() | All closed sprints |
| futureSprints() | Future sprints |

## Example Queries

### My Issues

```jql
assignee = currentUser() AND status != Done ORDER BY priority DESC
```

### Open Bugs in Project

```jql
project = PROJ AND type = Bug AND status = Open
```

### High Priority Unassigned

```jql
priority IN (High, Highest) AND assignee IS EMPTY
```

### Updated This Week

```jql
updated >= startOfWeek() ORDER BY updated DESC
```

### Created Last 7 Days

```jql
created >= -7d ORDER BY created DESC
```

### Issues in Current Sprint

```jql
sprint IN openSprints() AND project = PROJ
```

### Overdue Issues

```jql
duedate < now() AND status != Done
```

### Search in Summary/Description

```jql
summary ~ "performance" OR description ~ "slow"
```

### Issues Without Labels

```jql
project = PROJ AND labels IS EMPTY
```

### Recently Resolved

```jql
resolved >= -7d ORDER BY resolved DESC
```

### Blocked Issues

```jql
status = "Blocked" OR labels = "blocked"
```

### By Component

```jql
project = PROJ AND component = "Backend"
```

### Multiple Status

```jql
status IN ("To Do", "In Progress", "In Review")
```

### Exclude Subtasks

```jql
project = PROJ AND issuetype != Sub-task
```

## Custom Fields

Access custom fields by name or ID:

```jql
"Custom Field Name" = "value"
cf[10001] = "value"
```

## Tips

1. **Quote values with spaces**: `status = "In Progress"`
2. **Case insensitive**: Field names are case insensitive
3. **Use parentheses**: Group complex conditions `(A OR B) AND C`
4. **Escape special chars**: Use `\\` for backslash
5. **Empty values**: Use `IS EMPTY` or `IS NOT EMPTY`
</file>

<file path="skills/jira-self-hosted/SKILL.md">
---
name: jira-self-hosted
description: Query Jira Server/Data Center via REST API. Search issues (JQL), view issue details, list projects, view comments. Use for task tracking, sprint queries, issue lookup. READ-only operations.
version: 1.0.0
license: MIT
allowed-tools:
  - Bash
---

# Jira Self-Hosted (Server/Data Center)

Query and view Jira issues via REST API v2 with PAT authentication.

## When to Use

Use when:

- Searching issues with JQL queries
- Viewing issue details (summary, status, assignee)
- Listing projects
- Reading comments
- Answering questions about Jira data

**Scope: READ-only** (no create/update operations)

## Quick Reference

### Authentication

- **Reference**: `references/authentication.md` - PAT setup, header format, troubleshooting

### API Endpoints

- **Reference**: `references/api-reference.md` - Search, issues, projects, comments

### JQL Queries

- **Reference**: `references/jql-guide.md` - Syntax, operators, example queries

### Best Practices

- **Reference**: `references/best-practices.md` - Error handling, security, performance

### Helper Scripts

- `scripts/jira-auth-test.sh` - Validate PAT connection
- `scripts/jira-search.sh "JQL"` - Execute JQL queries
- `scripts/jira-issue-get.sh PROJ-123` - Get issue details

## Environment Setup

Required environment variables:

```bash
export JIRA_DOMAIN="https://your-jira-instance.com"
export JIRA_PAT="your_personal_access_token"
```

Or use `.env` file in scripts directory.

## Implementation Workflow

1. Set up environment variables (JIRA_DOMAIN, JIRA_PAT)
2. Test connection: `./scripts/jira-auth-test.sh`
3. Search issues: `./scripts/jira-search.sh "project = PROJ AND status = Open"`
4. View issue: `./scripts/jira-issue-get.sh PROJ-123`

## Platform Requirements

- Jira Server v8.14.0+ or Data Center (PAT support)
- `curl` and `jq` available in environment

## Defect Detection Logic

### ƒê·ªãnh nghƒ©a Defect

1. **Bug Type**: Issue c√≥ `issuetype = Bug`
2. **QC Reject**: Issue b·ªã reject t·ª´ Testing ‚Üí work states (To Do, In Progress, Resolved)

### Workflow chu·∫©n (KH√îNG ph·∫£i defect)

```
In Progress ‚Üí Resolved ‚Üí Testing ‚Üí Done
```

### Workflow c√≥ defect (QC Reject)

```
In Progress ‚Üí Resolved ‚Üí Testing ‚Üí [Resolved/In Progress/To Do] ‚Üí ... ‚Üí Done
                            ‚Üë
                      QC found issue
```

### Exclusions khi ƒë·∫øm defects by Developer

- Exclude: `DurianNhi` (QC), `Jira Automation`, `Unassigned`
- Developer = ng∆∞·ªùi move issue to `Resolved` (kh√¥ng ph·∫£i assignee)

### Metrics

- **Defect Rate** = (Bug Type + QC Rejects) / Total Issues √ó 100%
- **QC Reject** = Transition t·ª´ `testing` ‚Üí `{to do, in progress, in development, open, resolved}`
</file>

<file path="env.claude">
# Jira Server/Data Center Configuration
# Get PAT: Jira ‚Üí Profile ‚Üí Personal Access Tokens
# Priority: .env.dev > .env (delete .env.dev to use production)

JIRA_DOMAIN=https://your-jira-instance.com
JIRA_PAT=your_personal_access_token
</file>

<file path="install-skill.sh">
#!/bin/bash

# skill-jira-auto-report installer
# Copy skill to ~/.claude/skills/ and setup .env

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
SKILL_NAME="jira-self-hosted"
SKILL_SRC="$SCRIPT_DIR/skills/$SKILL_NAME"
SKILL_DEST="$HOME/.claude/skills/$SKILL_NAME"

echo "üöÄ Installing $SKILL_NAME skill..."

# Check if source exists
if [ ! -d "$SKILL_SRC" ]; then
    echo "‚ùå Error: Skill source not found at $SKILL_SRC"
    exit 1
fi

# Create destination directory
mkdir -p "$HOME/.claude/skills"

# Backup skill .env if exists
ENV_FILE="$SKILL_DEST/.env"
ENV_BACKUP=""

if [ -f "$ENV_FILE" ]; then
    ENV_BACKUP=$(cat "$ENV_FILE")
    echo "‚ÑπÔ∏è  Backed up existing skill .env"
fi

# Copy skill (overwrite if exists)
if [ -d "$SKILL_DEST" ]; then
    echo "‚ö†Ô∏è  Skill already exists, updating..."
    rm -rf "$SKILL_DEST"
fi

cp -r "$SKILL_SRC" "$SKILL_DEST"
echo "‚úÖ Copied skill to $SKILL_DEST"

# Make scripts executable
chmod +x "$SKILL_DEST/scripts/"*.sh 2>/dev/null || true
echo "‚úÖ Made scripts executable"

# Restore or create .env from env.claude template
ENV_TEMPLATE="$SCRIPT_DIR/env.claude"

if [ -n "$ENV_BACKUP" ]; then
    echo "$ENV_BACKUP" > "$ENV_FILE"
    echo "‚úÖ Restored existing .env"
    echo ""
    echo "‚ÑπÔ∏è  If you need to update config, check template: $ENV_TEMPLATE"
else
    if [ -f "$ENV_TEMPLATE" ]; then
        cp "$ENV_TEMPLATE" "$ENV_FILE"
        echo "‚úÖ Created .env from env.claude template"
    else
        echo "‚ö†Ô∏è  env.claude template not found, creating default .env"
        cat > "$ENV_FILE" << 'EOF'
# Jira Server/Data Center Configuration
# Get PAT: Jira ‚Üí Profile ‚Üí Personal Access Tokens

JIRA_DOMAIN=https://your-jira-instance.com
JIRA_PAT=your_personal_access_token
EOF
    fi
fi

# Setup project .env (for Telegram config) if not exists
PROJECT_ENV="$SCRIPT_DIR/.env"
PROJECT_ENV_EXAMPLE="$SCRIPT_DIR/.env.example"

if [ ! -f "$PROJECT_ENV" ] && [ -f "$PROJECT_ENV_EXAMPLE" ]; then
    cp "$PROJECT_ENV_EXAMPLE" "$PROJECT_ENV"
    echo "‚úÖ Created .env from .env.example (Telegram config)"
fi

echo ""
echo "üìã Next steps:"
echo "   1. Edit ~/.claude/skills/$SKILL_NAME/.env with your Jira credentials"
echo "   2. Edit $SCRIPT_DIR/.env with your Telegram credentials"
echo "   3. Test: ~/.claude/skills/$SKILL_NAME/scripts/jira-auth-test.sh"
echo "   4. Use in Claude: /jira-self-hosted or ask about Jira naturally"
echo ""
echo "‚ÑπÔ∏è  Note: Create .env.dev in project root for dev testing (daily-report.mjs only)"
echo ""
echo "‚ú® Installation complete!"
</file>

<file path="skills/jira-self-hosted/scripts/jira-auth-test.sh">
#!/usr/bin/env bash
# Validate Jira PAT authentication
# Usage: ./jira-auth-test.sh
# Exit: 0=success, 1=failure
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env
if [[ -f "$SCRIPT_DIR/../.env" ]]; then
  source "$SCRIPT_DIR/../.env"
fi

# Validate required vars
: "${JIRA_DOMAIN:?Error: JIRA_DOMAIN not set}"
: "${JIRA_PAT:?Error: JIRA_PAT not set}"

# Test authentication
response=$(curl -s -w "\n%{http_code}" \
  -H "Authorization: Bearer $JIRA_PAT" \
  -H "Content-Type: application/json" \
  "${JIRA_DOMAIN}/rest/api/2/myself")

http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | sed '$d')

if [[ "$http_code" == "200" ]]; then
  echo "$body"
  exit 0
else
  echo "{\"error\": \"Authentication failed\", \"http_code\": $http_code, \"response\": $body}" >&2
  exit 1
fi
</file>

<file path="skills/jira-self-hosted/scripts/jira-issue-get.sh">
#!/usr/bin/env bash
# Get Jira issue details
# Usage: ./jira-issue-get.sh PROJ-123 [-f summary,status,description]
# Exit: 0=success, 1=failure
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env
if [[ -f "$SCRIPT_DIR/../.env" ]]; then
  source "$SCRIPT_DIR/../.env"
fi

# Validate required vars
: "${JIRA_DOMAIN:?Error: JIRA_DOMAIN not set}"
: "${JIRA_PAT:?Error: JIRA_PAT not set}"

# Defaults
FIELDS=""
ISSUE_KEY=""

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -f|--fields)
      FIELDS="$2"
      shift 2
      ;;
    *)
      ISSUE_KEY="$1"
      shift
      ;;
  esac
done

if [[ -z "$ISSUE_KEY" ]]; then
  echo '{"error": "Issue key required. Usage: ./jira-issue-get.sh PROJ-123"}' >&2
  exit 1
fi

# Build URL with optional fields
url="${JIRA_DOMAIN}/rest/api/2/issue/${ISSUE_KEY}"
if [[ -n "$FIELDS" ]]; then
  url="${url}?fields=${FIELDS}"
fi

# Get issue
response=$(curl -s -w "\n%{http_code}" \
  -H "Authorization: Bearer $JIRA_PAT" \
  -H "Content-Type: application/json" \
  "$url")

http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | sed '$d')

if [[ "$http_code" == "200" ]]; then
  echo "$body"
  exit 0
else
  echo "{\"error\": \"Failed to get issue\", \"http_code\": $http_code, \"response\": $body}" >&2
  exit 1
fi
</file>

<file path="skills/jira-self-hosted/scripts/jira-search.sh">
#!/usr/bin/env bash
# Search Jira issues using JQL
# Usage: ./jira-search.sh "project = PROJ AND status = Open" [-m 50] [-f key,summary,status]
# Exit: 0=success, 1=failure
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Load .env
if [[ -f "$SCRIPT_DIR/../.env" ]]; then
  source "$SCRIPT_DIR/../.env"
fi

# Validate required vars
: "${JIRA_DOMAIN:?Error: JIRA_DOMAIN not set}"
: "${JIRA_PAT:?Error: JIRA_PAT not set}"

# Defaults
MAX_RESULTS=50
FIELDS="key,summary,status,assignee,priority"
JQL=""

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    -m|--max-results)
      MAX_RESULTS="$2"
      shift 2
      ;;
    -f|--fields)
      FIELDS="$2"
      shift 2
      ;;
    *)
      JQL="$1"
      shift
      ;;
  esac
done

if [[ -z "$JQL" ]]; then
  echo '{"error": "JQL query required. Usage: ./jira-search.sh \"project = PROJ\""}' >&2
  exit 1
fi

# Convert comma-separated fields to JSON array
fields_json=$(echo "$FIELDS" | jq -R 'split(",")')

# Build request body
request_body=$(jq -n \
  --arg jql "$JQL" \
  --argjson maxResults "$MAX_RESULTS" \
  --argjson fields "$fields_json" \
  '{jql: $jql, startAt: 0, maxResults: $maxResults, fields: $fields}')

# Execute search
response=$(curl -s -w "\n%{http_code}" \
  -X POST \
  -H "Authorization: Bearer $JIRA_PAT" \
  -H "Content-Type: application/json" \
  -d "$request_body" \
  "${JIRA_DOMAIN}/rest/api/2/search")

http_code=$(echo "$response" | tail -n1)
body=$(echo "$response" | sed '$d')

if [[ "$http_code" == "200" ]]; then
  echo "$body"
  exit 0
else
  echo "{\"error\": \"Search failed\", \"http_code\": $http_code, \"response\": $body}" >&2
  exit 1
fi
</file>

<file path=".env.example">
# ============================================
# TELEGRAM (d√πng b·ªüi daily-report.mjs)
# ============================================
TELEGRAM_BOT_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_private_chat_id
TELEGRAM_GROUP_CHAT_ID=your_group_chat_id
TELEGRAM_GROUP_THREAD_ID=your_thread_id
</file>

<file path=".gitignore">
.env.dev
.env
*.log
node_modules/
.vscode
.cursor
</file>

<file path="run-daily-report.sh">
#!/bin/bash

# Load environment variables: .env.dev (dev) > .env (prod)
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
set -a
if [[ -f "$SCRIPT_DIR/.env.dev" ]]; then
  source "$SCRIPT_DIR/.env.dev"
elif [[ -f "$SCRIPT_DIR/.env" ]]; then
  source "$SCRIPT_DIR/.env"
fi
set +a

cd "$SCRIPT_DIR"

# Retry logic - max 3 attempts with 60s delay
MAX_RETRIES=3
RETRY_DELAY=60
# Set node version
nvm use 20

for i in $(seq 1 $MAX_RETRIES); do
    echo "üîÑ Attempt $i/$MAX_RETRIES..."
    node daily-report.mjs && exit 0

    if [ $i -lt $MAX_RETRIES ]; then
        echo "‚è≥ Waiting ${RETRY_DELAY}s before retry..."
        sleep $RETRY_DELAY
    fi
done

echo "‚ùå Failed after $MAX_RETRIES attempts"
exit 1
</file>

<file path="daily-report.mjs">
#!/usr/bin/env node

import { spawn } from "child_process";

// ============================================================
// C·∫§U H√åNH - CH·ªàNH S·ª¨A THEO TEAM C·ª¶A B·∫†N
// ============================================================

// Danh s√°ch project Jira c·∫ßn theo d√µi
const JIRA_PROJECTS = ["PSV2", "DIC", "DEPOT", "AVA"];

// Project ch√≠nh ƒë·ªÉ l·∫•y danh s√°ch team members
const MAIN_PROJECT = "PSV2";

// Danh s√°ch user b·ªè qua (kh√¥ng t√≠nh v√†o b√°o c√°o)
const EXCLUDED_USERS = [
  "Jira Automation",
  "Unassigned",
  // Th√™m t√™n user c·∫ßn b·ªè qua ·ªü ƒë√¢y
];

// Workflow statuses trong Jira c·ªßa b·∫°n
// Ch·ªânh s·ª≠a n·∫øu Jira c·ªßa b·∫°n d√πng t√™n kh√°c
const JIRA_STATUSES = {
  done: "Done",           // Ho√†n th√†nh
  resolved: "Resolved",   // Dev xong, ch·ªù QC
  testing: "Testing",     // QC ƒëang test
  inProgress: "In Progress", // ƒêang l√†m
  toDo: "To Do",          // Ch∆∞a l√†m
};

// ============================================================
// TELEGRAM CONFIG (t·ª´ .env)
// ============================================================
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID; // For errors
const TELEGRAM_GROUP_CHAT_ID = process.env.TELEGRAM_GROUP_CHAT_ID; // For success
const TELEGRAM_GROUP_THREAD_ID = process.env.TELEGRAM_GROUP_THREAD_ID; // Thread in group

// ============================================================
// PROMPT TEMPLATE
// ============================================================
const projectList = JIRA_PROJECTS.join(", ");
const excludeList = EXCLUDED_USERS.map(u => `"${u}"`).join(", ");

const DAILY_PROMPT = `[CRITICAL INSTRUCTION] Your ENTIRE response must start with "üìä" - NO other text before it. Do NOT write any thinking, explanation, or narration like "T√¥i ƒë√£ c√≥ d·ªØ li·ªáu", "B√¢y gi·ªù t√¥i s·∫Ω", etc. ONLY output the report.

Daily report Jira h√¥m nay.

PROJECTS: ${projectList}

B∆Ø·ªöC 1 - L·∫§Y TEAM MEMBERS:
D√πng jira-self-hosted skill ƒë·ªÉ query API l·∫•y danh s√°ch team members:
GET /rest/api/2/user/assignable/search?project=${MAIN_PROJECT}&maxResults=100
Exclude: ${excludeList}

B∆Ø·ªöC 2 - L·∫§Y ISSUES H√îM QUA:
Query JQL: project IN (${projectList}) AND updated >= startOfDay(-1) AND updated < startOfDay()

B∆Ø·ªöC 3 - X√ÅC ƒê·ªäNH NG∆Ø·ªúI KH√îNG HO·∫†T ƒê·ªòNG:
So s√°nh team members v·ªõi assignees c√≥ task h√¥m qua ‚Üí list ng∆∞·ªùi kh√¥ng c√≥ task n√†o

B·∫ÆT BU·ªòC:
1. Output B·∫ÆT ƒê·∫¶U NGAY b·∫±ng üìä - TUY·ªÜT ƒê·ªêI KH√îNG c√≥ text n√†o tr∆∞·ªõc ƒë√≥
2. KH√îNG vi·∫øt c√¢u m·ªü ƒë·∫ßu nh∆∞: "T√¥i ƒë√£ c√≥ d·ªØ li·ªáu", "B√¢y gi·ªù t√¥i s·∫Ω", "D·ª±a tr√™n", "T·ªïng h·ª£p", "ph√¢n t√≠ch v√† t·∫°o b√°o c√°o", hay b·∫•t k·ª≥ gi·∫£i th√≠ch/narration n√†o
3. KH√îNG d√πng markdown ** ho·∫∑c __ - CH·ªà d√πng HTML <b></b>
4. KH√îNG d√πng table markdown | ho·∫∑c ---
5. CH·ªà output b√°o c√°o theo FORMAT b√™n d∆∞·ªõi, KH√îNG c√≥ b·∫•t k·ª≥ text n√†o kh√°c

FORMAT (copy ch√≠nh x√°c c·∫•u tr√∫c n√†y):

üìä <b>B√ÅO C√ÅO JIRA - [ng√†y h√¥m qua]</b>

<b>T·ªîNG QUAN</b>
‚úÖ Done: X | üìã Resolved: X | üß™ Testing: X | üîÑ In Progress: X

<b>THEO NG∆Ø·ªúI</b>
üë§ T√™n: ‚úÖX üìãX üß™X üîÑX

<b>CHI TI·∫æT DONE</b>
‚Ä¢ KEY: M√¥ t·∫£ (Assignee)

<b>CHI TI·∫æT RESOLVED</b> (Dev xong, ch·ªù QC)
‚Ä¢ KEY: M√¥ t·∫£ (Assignee)

<b>CHI TI·∫æT TESTING</b>
‚Ä¢ KEY: M√¥ t·∫£ (Assignee)

<b>CHI TI·∫æT IN PROGRESS</b>
‚Ä¢ KEY: M√¥ t·∫£ (Assignee)

<b>üêõ BUG/REOPEN/REJECT</b>
‚Ä¢ KEY: M√¥ t·∫£ (Assignee) - tr·∫°ng th√°i (ho·∫∑c "Kh√¥ng c√≥")

<b>GHI CH√ö</b>
‚Ä¢ üò¥ Kh√¥ng ho·∫°t ƒë·ªông: T√™n1, T√™n2 (t·ª´ B∆Ø·ªöC 3 - nh·ªØng ng∆∞·ªùi trong team nh∆∞ng kh√¥ng c√≥ task h√¥m nay)
‚Ä¢ Ghi ch√∫ kh√°c n·∫øu c√≥`;

function runClaudeCode(prompt) {
  return new Promise((resolve, reject) => {
    console.log("üìù Prompt:", prompt.slice(0, 50) + "...");

    // Ch·∫°y claude CLI v·ªõi flag --print (ch·ªâ output, kh√¥ng interactive)
    const claude = spawn(
      "claude",
      ["-p", prompt, "--output-format", "text", "--dangerously-skip-permissions"],
      {
        env: { ...process.env },
        stdio: ["ignore", "pipe", "pipe"], // Ignore stdin to force non-interactive
      }
    );

    console.log("üöÄ Claude process started, PID:", claude.pid);

    // Timeout 5 ph√∫t
    const timeout = setTimeout(() => {
      console.log("‚è∞ Timeout! Killing process...");
      claude.kill();
      reject(new Error("Claude timed out after 5 minutes"));
    }, 5 * 60 * 1000);

    let output = "";
    let error = "";

    claude.stdout.on("data", (data) => {
      const chunk = data.toString();
      process.stdout.write(chunk); // Stream output realtime
      output += chunk;
    });

    claude.stderr.on("data", (data) => {
      const chunk = data.toString();
      process.stderr.write(chunk); // Stream errors realtime
      error += chunk;
    });

    claude.on("close", (code) => {
      clearTimeout(timeout);
      console.log("üèÅ Claude exited with code:", code);
      if (code === 0) {
        resolve(output.trim());
      } else {
        reject(new Error(`Claude exited with code ${code}: ${error}`));
      }
    });

    claude.on("error", (err) => {
      clearTimeout(timeout);
      console.error("üí• Spawn error:", err.message);
      reject(err);
    });
  });
}

async function sendTelegramMessage(text, chatId, threadId = null) {
  // Telegram c√≥ limit 4096 chars, c·∫ßn split n·∫øu d√†i
  const chunks = splitMessage(text, 4000);

  for (const chunk of chunks) {
    const url = `https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage`;
    const body = {
      chat_id: chatId,
      text: chunk,
      parse_mode: "HTML",
    };
    if (threadId) {
      body.message_thread_id = parseInt(threadId);
    }
    await fetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    });
  }
}

function splitMessage(text, maxLength) {
  // N·∫øu text ng·∫Øn, tr·∫£ v·ªÅ nguy√™n
  if (text.length <= maxLength) {
    return [text];
  }

  // Split theo d√≤ng ƒë·ªÉ kh√¥ng c·∫Øt gi·ªØa ch·ª´ng
  const lines = text.split("\n");
  const chunks = [];
  let current = "";

  for (const line of lines) {
    if ((current + "\n" + line).length > maxLength) {
      if (current) chunks.push(current.trim());
      current = line;
    } else {
      current = current ? current + "\n" + line : line;
    }
  }
  if (current) chunks.push(current.trim());

  return chunks;
}

async function main() {
  try {
    console.log("ü§ñ Running Claude Code with skills...");
    const response = await runClaudeCode(DAILY_PROMPT);

    // Success ‚Üí send to group thread
    console.log("üì§ Sending to Telegram Group...");
    await sendTelegramMessage(response, TELEGRAM_GROUP_CHAT_ID, TELEGRAM_GROUP_THREAD_ID);

    console.log("‚úÖ Done!");
  } catch (error) {
    console.error("‚ùå Error:", error.message);
    // Error ‚Üí send to private chat
    await sendTelegramMessage(`‚ùå <b>Daily Report Failed</b>\n\nError: ${error.message}`, TELEGRAM_CHAT_ID);
    process.exit(1);
  }
}

main();
</file>

<file path="README.md">
# skill-jira-auto-report

**English below**

ü§ñ Claude Code skill ƒë·ªÉ t·∫°o b√°o c√°o Jira t·ª± ƒë·ªông v√† g·ª≠i qua Telegram.

**Ch·ªâ h·ªó tr·ª£ Jira Server/Data Center** (Self-Hosted) v·ªõi PAT authentication.

---

## üöÄ C√°ch s·ª≠ d·ª•ng ch√≠nh: H·ªèi ƒë√°p qua Claude Code CLI

**ƒê√¢y l√† c√°ch s·ª≠ d·ª•ng ch√≠nh v√† ƒë∆°n gi·∫£n nh·∫•t.**

Sau khi c√†i ƒë·∫∑t skill, b·∫°n c√≥ th·ªÉ h·ªèi Claude b·∫•t k·ª≥ ƒëi·ªÅu g√¨ v·ªÅ Jira:

```bash
# M·ªü Claude Code CLI
claude

# Sau ƒë√≥ h·ªèi t·ª± nhi√™n:
> T·ªïng h·ª£p task c·ªßa team h√¥m qua
> Ai ƒëang l√†m g√¨ trong project PSV2?
> List c√°c bug ch∆∞a fix trong sprint n√†y
> Th·ªëng k√™ s·ªë task done c·ªßa t·ª´ng ng∆∞·ªùi tu·∫ßn n√†y
> Task n√†o ƒëang b·ªã block?
```

Claude s·∫Ω t·ª± ƒë·ªông s·ª≠ d·ª•ng skill `jira-self-hosted` ƒë·ªÉ query Jira v√† tr·∫£ l·ªùi.

**∆Øu ƒëi·ªÉm:**
- Kh√¥ng c·∫ßn nh·ªõ JQL syntax
- H·ªèi b·∫±ng ng√¥n ng·ªØ t·ª± nhi√™n (Ti·∫øng Vi·ªát/English)
- Claude t·ª± format k·∫øt qu·∫£ d·ªÖ ƒë·ªçc

---

## C·∫•u h√¨nh Workflow Logic (Bug/Reopen Detection)

Claude hi·ªÉu workflow th√¥ng qua **2 file**:

| File | M·ª•c ƒë√≠ch |
|------|----------|
| `skills/jira-self-hosted/SKILL.md` | ƒê·ªãnh nghƒ©a logic detect Bug, QC Reject, Reopen |
| `daily-report.mjs` ‚Üí `DAILY_PROMPT` | H∆∞·ªõng d·∫´n c√°ch format output |

**ƒê·ªÉ thay ƒë·ªïi c√°ch detect Bug/Reopen:**

1. M·ªü `skills/jira-self-hosted/SKILL.md`
2. T√¨m section `## Defect Detection Logic`
3. Ch·ªânh s·ª≠a ƒë·ªãnh nghƒ©a theo workflow c·ªßa b·∫°n

V√≠ d·ª• th√™m Reopen logic:
```markdown
### Reopen Definition
- Issue chuy·ªÉn t·ª´ Done ‚Üí b·∫•t k·ª≥ status n√†o kh√°c = Reopen
```

Claude s·∫Ω ƒë·ªçc SKILL.md v√† √°p d·ª•ng logic n√†y khi generate report.

---

## Ph·∫ßn 1: S·ª≠ d·ª•ng v·ªõi Claude CLI (Interactive)

### Y√™u c·∫ßu
- [Claude Code CLI](https://github.com/anthropics/claude-code) ƒë√£ c√†i ƒë·∫∑t v√† authenticate
- Jira Server/Data Center v8.14.0+ (h·ªó tr·ª£ PAT)

### C√†i ƒë·∫∑t Skill

```bash
# Ch·∫°y script c√†i ƒë·∫∑t
./install-skill.sh

# C·∫•u h√¨nh Jira credentials
nano ~/.claude/skills/jira-self-hosted/.env

# Test k·∫øt n·ªëi
~/.claude/skills/jira-self-hosted/scripts/jira-auth-test.sh
```

### Development Environment (Optional)

ƒê·ªÉ test daily report v·ªõi dev Telegram, t·∫°o file `.env.dev` trong project root:

```bash
# T·∫°o .env.dev (∆∞u ti√™n h∆°n .env cho daily-report.mjs)
nano .env.dev
```

**Priority:** `.env.dev` > `.env` (ch·ªâ √°p d·ª•ng cho `run-daily-report.sh`)

### L·∫•y Jira PAT

1. ƒêƒÉng nh·∫≠p Jira ‚Üí Profile ‚Üí Personal Access Tokens
2. Create token ‚Üí Copy token
3. Th√™m v√†o `.env` ho·∫∑c `.env.dev`

### C√°ch Prompt

Trong Claude CLI, b·∫°n c√≥ th·ªÉ prompt:

```
Daily report Jira h√¥m qua.
Projects: PSV2, DIC, DEPOT

D√πng jira-self-hosted skill ƒë·ªÉ:
1. Query issues updated h√¥m qua
2. Group theo status: Done, Resolved, Testing, In Progress
3. List theo ng∆∞·ªùi
```

Ho·∫∑c ƒë∆°n gi·∫£n:

```
/jira-self-hosted

T·ªïng h·ª£p ho·∫°t ƒë·ªông team h√¥m qua cho projects PSV2, DIC
```

### Tham kh·∫£o

- `skills/jira-self-hosted/references/jql-guide.md` - C√∫ ph√°p JQL
- `skills/jira-self-hosted/references/api-reference.md` - API endpoints

---

## Ph·∫ßn 2: Ch·∫°y t·ª± ƒë·ªông v·ªõi Cron

Chuy·ªÉn ƒë·ªïi th√†nh script ch·∫°y ƒë·ªãnh k·ª≥, g·ª≠i report qua Telegram.

### Y√™u c·∫ßu th√™m
- Node.js 18+
- Telegram Bot
- Claude Code ƒë√£ authenticate tr√™n server

### Authentication

Script s·ª≠ d·ª•ng authentication c·ªßa Claude Code CLI. N·∫øu ch·∫°y t·ª± ƒë·ªông tr√™n server:

```bash
# SSH v√†o server
ssh user@server

# Login Claude Code 1 l·∫ßn
claude login

# Verify
claude --version
```

Sau khi login, Claude Code l∆∞u credentials t·∫°i `~/.claude/` - cron job s·∫Ω t·ª± ƒë·ªông s·ª≠ d·ª•ng.

### B∆∞·ªõc 1: C·∫•u h√¨nh Environment

‚ö†Ô∏è **C√≥ 2 file .env ri√™ng bi·ªát:**

| File | D√πng b·ªüi | Bi·∫øn |
|------|----------|------|
| `./.env` | `daily-report.mjs` | `TELEGRAM_*` |
| `~/.claude/skills/jira-self-hosted/.env` | Skill scripts | `JIRA_*` |

**1a. Telegram .env (project root):**
```bash
# install-skill.sh t·ª± ƒë·ªông copy n·∫øu ch∆∞a c√≥
nano .env
```

```bash
TELEGRAM_BOT_TOKEN=123456:ABC...      # Token t·ª´ @BotFather
TELEGRAM_CHAT_ID=123456789            # Chat ID cho error notifications
TELEGRAM_GROUP_CHAT_ID=-100123456789  # Group ID cho daily report
TELEGRAM_GROUP_THREAD_ID=123          # Thread ID trong group (n·∫øu c√≥)
```

**1b. Jira .env (skill folder):**
```bash
# install-skill.sh t·ª± ƒë·ªông t·∫°o t·ª´ env.claude template
nano ~/.claude/skills/jira-self-hosted/.env
```

### B∆∞·ªõc 2: L·∫•y Telegram IDs

**Bot Token:**
1. Chat v·ªõi @BotFather ‚Üí `/newbot` ‚Üí copy token

**Chat ID (private):**
1. Chat v·ªõi @userinfobot ‚Üí Copy "Id"

**Group Chat ID:**
1. Th√™m bot v√†o group
2. G·ª≠i message trong group
3. Truy c·∫≠p: `https://api.telegram.org/bot<TOKEN>/getUpdates`
4. T√¨m `"chat":{"id":-100...}`

**Thread ID (n·∫øu d√πng Topics):**
- Trong response `getUpdates`, t√¨m `"message_thread_id"`

### B∆∞·ªõc 3: C√†i ƒë·∫∑t Skill

```bash
# Ch·∫°y installer (t·ª± t·∫°o .env template n·∫øu ch∆∞a c√≥)
./install-skill.sh
# Jira .env ƒë√£ t·∫°o ·ªü B∆∞·ªõc 1b
```

### B∆∞·ªõc 4: Test

```bash
# Test Jira
~/.claude/skills/jira-self-hosted/scripts/jira-auth-test.sh

# Test report
./run-daily-report.sh
```

### B∆∞·ªõc 5: Setup Cron

```bash
crontab -e
```

Th√™m (8h s√°ng Vietnam = 1h UTC):

```cron
0 1 * * * /path/to/skill-jira-auto-report/run-daily-report.sh >> /path/to/daily-report.log 2>&1
```

### C·∫•u tr√∫c

| File | M√¥ t·∫£ |
|------|-------|
| `run-daily-report.sh` | Load .env, retry 3x, g·ªçi Node |
| `daily-report.mjs` | Spawn Claude CLI, g·ª≠i Telegram |

### Logic g·ª≠i Telegram

- ‚úÖ Success ‚Üí `TELEGRAM_GROUP_CHAT_ID` (thread n·∫øu c√≥)
- ‚ùå Error ‚Üí `TELEGRAM_CHAT_ID` (private)

### T√πy ch·ªânh c·∫•u h√¨nh

M·ªü `daily-report.mjs` v√† ch·ªânh ph·∫ßn **C·∫§U H√åNH** ·ªü ƒë·∫ßu file:

```javascript
// Danh s√°ch project Jira c·∫ßn theo d√µi
const JIRA_PROJECTS = ["PSV2", "DIC", "DEPOT", "AVA"];

// Project ch√≠nh ƒë·ªÉ l·∫•y danh s√°ch team members
const MAIN_PROJECT = "PSV2";

// Danh s√°ch user b·ªè qua (kh√¥ng t√≠nh v√†o b√°o c√°o)
const EXCLUDED_USERS = [
  "Jira Automation",
  "Unassigned",
  // Th√™m t√™n user c·∫ßn b·ªè qua ·ªü ƒë√¢y
];
```

| Bi·∫øn | M√¥ t·∫£ |
|------|-------|
| `JIRA_PROJECTS` | M·∫£ng c√°c project key c·∫ßn theo d√µi |
| `MAIN_PROJECT` | Project d√πng ƒë·ªÉ query danh s√°ch team members |
| `EXCLUDED_USERS` | Users kh√¥ng t√≠nh (bot, automation, manager...)|
| `JIRA_STATUSES` | Mapping t√™n status trong Jira c·ªßa b·∫°n |

### Workflow Statuses

```javascript
const JIRA_STATUSES = {
  done: "Done",           // Ho√†n th√†nh
  resolved: "Resolved",   // Dev xong, ch·ªù QC
  testing: "Testing",     // QC ƒëang test
  inProgress: "In Progress", // ƒêang l√†m
  toDo: "To Do",          // Ch∆∞a l√†m
};
```

**Workflow chu·∫©n:**
```
To Do ‚Üí In Progress ‚Üí Resolved ‚Üí Testing ‚Üí Done
```

‚ö†Ô∏è **L∆∞u √Ω:** N·∫øu Jira c·ªßa b·∫°n d√πng t√™n status kh√°c (v√≠ d·ª•: "QA Testing" thay v√¨ "Testing"), h√£y ch·ªânh `JIRA_STATUSES` cho ph√π h·ª£p.

### T√πy ch·ªânh Prompt

Ch·ªânh `DAILY_PROMPT` trong `daily-report.mjs` n·∫øu mu·ªën thay ƒë·ªïi format b√°o c√°o

---

## Troubleshooting

| L·ªói | Gi·∫£i ph√°p |
|-----|-----------|
| PAT invalid | Ki·ªÉm tra token, JIRA_DOMAIN kh√¥ng trailing slash |
| API Error 500 | Anthropic server l·ªói, script t·ª± retry 3 l·∫ßn |
| Kh√¥ng nh·∫≠n Telegram | Bot ƒë√£ add v√†o group? Thread ID ƒë√∫ng? |

---

## License

MIT

---

# English Version

ü§ñ Claude Code skill for automated Jira daily reports sent via Telegram.

**Only supports Jira Server/Data Center** (Self-Hosted) with PAT authentication.

---

## üöÄ Primary Usage: Q&A via Claude Code CLI

**This is the main and simplest way to use this skill.**

After installing the skill, ask Claude anything about Jira:

```bash
# Open Claude Code CLI
claude

# Then ask naturally:
> Summarize team tasks from yesterday
> Who is working on what in project PSV2?
> List unfixed bugs in this sprint
> Statistics of done tasks per person this week
> Which tasks are blocked?
```

Claude will automatically use `jira-self-hosted` skill to query Jira and respond.

**Benefits:**
- No need to remember JQL syntax
- Ask in natural language (Vietnamese/English)
- Claude formats results for readability

---

> ‚ö†Ô∏è **IMPORTANT NOTE**
>
> The workflow and configuration in this repo are based on the author's specific setup. **You need to customize** the following settings to match your team's workflow:
> - Project list (`JIRA_PROJECTS`)
> - Workflow status names (`JIRA_STATUSES`)
> - Excluded users list (`EXCLUDED_USERS`)
> - Report format (`DAILY_PROMPT`)
>
> See **"Configuration"** section for details.

---

## Part 1: Using with Claude CLI (Interactive)

### Requirements
- [Claude Code CLI](https://github.com/anthropics/claude-code) installed and authenticated
- Jira Server/Data Center v8.14.0+ (PAT support)

### Install Skill

```bash
# Run installer
./install-skill.sh

# Configure Jira credentials
nano ~/.claude/skills/jira-self-hosted/.env

# Test connection
~/.claude/skills/jira-self-hosted/scripts/jira-auth-test.sh
```

### Get Jira PAT

1. Login Jira ‚Üí Profile ‚Üí Personal Access Tokens
2. Create token ‚Üí Copy token
3. Add to `.env` or `.env.dev`

### Development Environment (Optional)

To test daily report with dev Telegram, create `.env.dev` in project root:

```bash
nano .env.dev
```

**Priority:** `.env.dev` > `.env` (only applies to `run-daily-report.sh`)

### How to Prompt

```
Daily report for yesterday.
Projects: PSV2, DIC, DEPOT

Use jira-self-hosted skill to:
1. Query issues updated yesterday
2. Group by status: Done, Resolved, Testing, In Progress
3. List by person
```

---

## Part 2: Automated Cron Job

### Additional Requirements
- Node.js 18+
- Telegram Bot
- Claude Code authenticated on server

### Authentication

```bash
ssh user@server
claude login
claude --version
```

### Step 1: Configure Environment

‚ö†Ô∏è **There are 2 separate .env files:**

| File | Used by | Variables |
|------|---------|-----------|
| `./.env` | `daily-report.mjs` | `TELEGRAM_*` |
| `~/.claude/skills/jira-self-hosted/.env` | Skill scripts | `JIRA_*` |

**1a. Telegram .env (project root):**
```bash
# install-skill.sh t·ª± ƒë·ªông copy n·∫øu ch∆∞a c√≥
nano .env
```

```bash
TELEGRAM_BOT_TOKEN=123456:ABC...
TELEGRAM_CHAT_ID=123456789            # For errors
TELEGRAM_GROUP_CHAT_ID=-100123456789  # For success
TELEGRAM_GROUP_THREAD_ID=123          # Thread ID (optional)
```

**1b. Jira .env (skill folder):**
```bash
# install-skill.sh t·ª± ƒë·ªông t·∫°o t·ª´ env.claude template
nano ~/.claude/skills/jira-self-hosted/.env
```

### Step 2: Get Telegram IDs

**Bot Token:** Chat @BotFather ‚Üí `/newbot` ‚Üí copy token

**Chat ID:** Chat @userinfobot ‚Üí Copy "Id"

**Group Chat ID:**
1. Add bot to group
2. Send message in group
3. Visit: `https://api.telegram.org/bot<TOKEN>/getUpdates`
4. Find `"chat":{"id":-100...}`

### Step 3: Install Skill

```bash
# Run installer (creates .env template if not exists)
./install-skill.sh
# Jira .env already created in Step 1b
```

### Step 4: Test

```bash
~/.claude/skills/jira-self-hosted/scripts/jira-auth-test.sh
./run-daily-report.sh
```

### Step 5: Setup Cron

```bash
crontab -e
```

Add (8am Vietnam = 1am UTC):

```cron
0 1 * * * /path/to/skill-jira-auto-report/run-daily-report.sh >> /path/to/daily-report.log 2>&1
```

### Configuration

Edit `daily-report.mjs`:

```javascript
const JIRA_PROJECTS = ["PSV2", "DIC", "DEPOT", "AVA"];
const MAIN_PROJECT = "PSV2";
const EXCLUDED_USERS = ["Jira Automation", "Unassigned"];
```

### Workflow Statuses

```javascript
const JIRA_STATUSES = {
  done: "Done",
  resolved: "Resolved",   // Dev done, waiting QC
  testing: "Testing",     // QC testing
  inProgress: "In Progress",
  toDo: "To Do",
};
```

**Standard workflow:**
```
To Do ‚Üí In Progress ‚Üí Resolved ‚Üí Testing ‚Üí Done
```

‚ö†Ô∏è If your Jira uses different status names, update `JIRA_STATUSES` accordingly.

### Workflow Logic Configuration (Bug/Reopen Detection)

Claude understands workflow through **2 files**:

| File | Purpose |
|------|---------|
| `skills/jira-self-hosted/SKILL.md` | Defines Bug, QC Reject, Reopen detection logic |
| `daily-report.mjs` ‚Üí `DAILY_PROMPT` | Output format instructions |

**To change Bug/Reopen detection:**

1. Open `skills/jira-self-hosted/SKILL.md`
2. Find `## Defect Detection Logic` section
3. Modify definitions to match your workflow

Example - add Reopen logic:
```markdown
### Reopen Definition
- Issue moved from Done ‚Üí any other status = Reopen
```

Claude reads SKILL.md and applies this logic when generating reports.

### Telegram Logic

- ‚úÖ Success ‚Üí `TELEGRAM_GROUP_CHAT_ID`
- ‚ùå Error ‚Üí `TELEGRAM_CHAT_ID`

---

## Troubleshooting

| Error | Solution |
|-------|----------|
| PAT invalid | Check token, JIRA_DOMAIN without trailing slash |
| API Error 500 | Anthropic server error, script retries 3 times |
| No Telegram message | Bot added to group? Thread ID correct? |
</file>

</files>
